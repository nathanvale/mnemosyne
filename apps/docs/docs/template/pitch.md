# ğŸª Pitch: [Feature Name]

## ğŸ¯ Problem

_What's the specific problem we're solving?_

In 2-3 sentences, describe:

- The current pain point or limitation
- Who experiences this problem
- Why solving it matters now

## ğŸƒ Appetite

_How much time/energy we're willing to spend_

- **Time Investment**: [1-2 weeks / 3-4 weeks / 6 weeks]
- **Team Size**: [Solo / Pair / Small team]
- **Complexity**: [Simple / Medium / Complex]

If this takes longer than our appetite, we'll **cut scope**, not extend time.

## ğŸ¨ Solution

_What we're going to build_

### Core Functionality

Brief description of the main feature:

- What users will be able to do
- How it integrates with existing system
- Key user interactions

### What It Looks Like

_Visual or conceptual overview_

For UI features: Rough wireframes or descriptions
For API features: Basic request/response examples
For internal features: Data flow or process diagrams

## ğŸ—ï¸ How It Works

_Technical approach at a high level_

### Key Components

1. **Component A**: [What it does]
2. **Component B**: [What it does]
3. **Component C**: [What it does]

### Technical Approach

- **Architecture**: [High-level technical strategy]
- **Packages Affected**: @studio/[package], @studio/[package]
- **New Dependencies**: [Any new tools/libraries needed]

## ğŸ“‹ Scope

_What's included and what's not_

### âœ… This Cycle

- [ ] Core functionality that users need
- [ ] Basic error handling
- [ ] Integration with existing system
- [ ] Simple UI (if applicable)

### âŒ Not This Cycle

- Advanced features that would be nice
- Complex edge cases
- Performance optimization
- Advanced UI polish

### ğŸš« No-Gos

- Features that would double the scope
- Integrations that require external dependencies
- Anything that needs extensive research

## ğŸ› ï¸ Implementation Plan

_Rough phases of work_

### Week 1: Foundation

- [ ] Set up basic structure
- [ ] Core logic implementation
- [ ] Basic testing

### Week 2: Integration

- [ ] Connect to existing system
- [ ] User interface (if needed)
- [ ] End-to-end testing

### Week 3: Polish (if needed)

- [ ] Edge case handling
- [ ] Performance improvements
- [ ] Documentation

## ğŸ¯ Success Metrics

_How we'll know this is working_

- **Functional**: [What behavior we expect]
- **User Experience**: [How users will benefit]
- **Technical**: [Performance or reliability goals]

## ğŸš¨ Risks

_What could go wrong and our backup plan_

### Technical Risks

- **Risk**: [Specific concern]
  - **Mitigation**: [How we'll handle it]

### Scope Risks

- **Risk**: Feature creep or complexity explosion
  - **Mitigation**: Stick to core scope, cut features if needed

## ğŸ”„ Circuit Breaker

_When to stop and reassess_

If we encounter:

- Technical blockers that take more than 2 days to resolve
- Scope expanding beyond our appetite
- Dependencies that aren't ready

Then we'll **stop**, reassess, and either:

- Cut scope to fit appetite
- Reschedule for a future cycle
- Break into smaller pieces

## ğŸ“¦ Package Impact

_Which parts of the codebase will change_

- **@studio/[package]**: [What changes]
- **@studio/[package]**: [What changes]
- **Tests**: [New test files or modifications]
- **Documentation**: [What docs need updating]

## ğŸª Demo Plan

_How we'll show this feature when complete_

- **Scenario**: [Real user scenario to demonstrate]
- **Data**: [What test data we'll use]
- **Flow**: [Step-by-step demo flow]

---

_This pitch represents work that can be completed in a single cycle. If it's too big, break it down or cut scope._
