{
  "version": 3,
  "sources": ["../src/quality-check/index.ts", "../src/types/claude.ts", "../src/utils/file-utils.ts", "../src/utils/logger.ts", "../src/quality-check/checkers/common-issues.ts", "../src/quality-check/checkers/eslint.ts", "../src/utils/config-loader.ts", "../src/quality-check/dummy-generator.ts", "../src/quality-check/import-parser.ts", "../src/quality-check/checkers/prettier.ts", "../src/quality-check/checkers/typescript.ts", "../src/quality-check/config.ts", "../src/quality-check/typescript-cache.ts"],
  "sourcesContent": ["/**\n * React App Quality Check Hook\n * Optimized for React applications with sensible defaults\n */\n\nimport path from 'path'\n\nimport type { FileToolInput } from '../types/claude.js'\n\nimport { HookExitCode } from '../types/claude.js'\nimport {\n  parseJsonInput,\n  fileExists,\n  isSourceFile,\n} from '../utils/file-utils.js'\nimport { createLogger, colors } from '../utils/logger.js'\nimport { createCommonIssuesChecker } from './checkers/common-issues.js'\nimport { createESLintChecker } from './checkers/eslint.js'\nimport { createPrettierChecker } from './checkers/prettier.js'\nimport { createTypeScriptChecker } from './checkers/typescript.js'\nimport { loadQualityConfig } from './config.js'\nimport { TypeScriptConfigCache } from './typescript-cache.js'\n\n/**\n * Quality checker for a single file\n */\nclass QualityChecker {\n  private filePath: string\n  private fileType: string\n  private errors: string[] = []\n  private autofixes: string[] = []\n\n  constructor(filePath: string) {\n    this.filePath = filePath\n    this.fileType = this.detectFileType(filePath)\n  }\n\n  /**\n   * Detect file type from path\n   */\n  private detectFileType(filePath: string): string {\n    if (/\\.(test|spec)\\.(ts|tsx|js|jsx)$/.test(filePath)) {\n      return 'test'\n    }\n    if (/\\/store\\/|\\/slices\\/|\\/reducers\\//.test(filePath)) {\n      return 'redux'\n    }\n    if (/\\/components\\/.*\\.(tsx|jsx)$/.test(filePath)) {\n      return 'component'\n    }\n    if (/\\.(ts|tsx)$/.test(filePath)) {\n      return 'typescript'\n    }\n    if (/\\.(js|jsx)$/.test(filePath)) {\n      return 'javascript'\n    }\n    return 'unknown'\n  }\n\n  /**\n   * Run all quality checks\n   */\n  async checkAll(\n    config: Awaited<ReturnType<typeof loadQualityConfig>>,\n    log: ReturnType<typeof createLogger>,\n    tsConfigCache: TypeScriptConfigCache,\n  ): Promise<{ errors: string[]; autofixes: string[] }> {\n    if (this.fileType === 'unknown') {\n      log.info('Unknown file type, skipping detailed checks')\n      return { errors: [], autofixes: [] }\n    }\n\n    // Create checkers\n    const checkers = await Promise.all([\n      createTypeScriptChecker(this.filePath, config, log, tsConfigCache),\n      createESLintChecker(this.filePath, config, log),\n      createPrettierChecker(this.filePath, config, log),\n      createCommonIssuesChecker(this.filePath, config, log),\n    ])\n\n    // Run checks in parallel\n    const results = await Promise.all([\n      checkers[0] ? checkers[0].check() : Promise.resolve([]),\n      checkers[1]\n        ? checkers[1].check()\n        : Promise.resolve({ errors: [], autofixes: [] }),\n      checkers[2]\n        ? checkers[2].check()\n        : Promise.resolve({ errors: [], autofixes: [] }),\n      checkers[3].check(this.fileType),\n    ])\n\n    // Collect results\n    this.errors.push(...(results[0] as string[]))\n    this.errors.push(...results[1].errors)\n    this.autofixes.push(...results[1].autofixes)\n    this.errors.push(...results[2].errors)\n    this.autofixes.push(...results[2].autofixes)\n    this.errors.push(...results[3])\n\n    // Check for related tests\n    await this.suggestRelatedTests(log)\n\n    return {\n      errors: this.errors,\n      autofixes: this.autofixes,\n    }\n  }\n\n  /**\n   * Suggest related test files\n   */\n  private async suggestRelatedTests(\n    log: ReturnType<typeof createLogger>,\n  ): Promise<void> {\n    if (this.fileType === 'test') {\n      return\n    }\n\n    const baseName = this.filePath.replace(/\\.[^.]+$/, '')\n    const testExtensions = ['test.ts', 'test.tsx', 'spec.ts', 'spec.tsx']\n    let hasTests = false\n\n    for (const ext of testExtensions) {\n      if (await fileExists(`${baseName}.${ext}`)) {\n        hasTests = true\n        log.warning(`\uD83D\uDCA1 Related test found: ${path.basename(baseName)}.${ext}`)\n        log.warning('   Consider running the tests to ensure nothing broke')\n        break\n      }\n    }\n\n    // Check __tests__ directory\n    if (!hasTests) {\n      const dir = path.dirname(this.filePath)\n      const fileName = path.basename(this.filePath)\n      const baseFileName = fileName.replace(/\\.[^.]+$/, '')\n\n      for (const ext of testExtensions) {\n        if (\n          await fileExists(\n            path.join(dir, '__tests__', `${baseFileName}.${ext}`),\n          )\n        ) {\n          hasTests = true\n          log.warning(`\uD83D\uDCA1 Related test found: __tests__/${baseFileName}.${ext}`)\n          log.warning('   Consider running the tests to ensure nothing broke')\n          break\n        }\n      }\n    }\n\n    if (!hasTests) {\n      log.warning(`\uD83D\uDCA1 No test file found for ${path.basename(this.filePath)}`)\n      log.warning('   Consider adding tests for better code quality')\n    }\n\n    // Special reminders\n    if (/\\/state\\/slices\\//.test(this.filePath)) {\n      log.warning('\uD83D\uDCA1 Redux state file! Consider testing state updates')\n    } else if (/\\/components\\//.test(this.filePath)) {\n      log.warning('\uD83D\uDCA1 Component file! Consider testing UI behavior')\n    } else if (/\\/services\\//.test(this.filePath)) {\n      log.warning('\uD83D\uDCA1 Service file! Consider testing business logic')\n    }\n  }\n}\n\n/**\n * Extract file path from tool input\n */\nfunction extractFilePath(input: FileToolInput): string | null {\n  const { tool_input } = input\n  if (!tool_input) {\n    return null\n  }\n\n  return (\n    tool_input.file_path || tool_input.path || tool_input.notebook_path || null\n  )\n}\n\n/**\n * Print summary of errors and autofixes\n */\nfunction printSummary(errors: string[], autofixes: string[]): void {\n  // Show auto-fixes if any\n  if (autofixes.length > 0) {\n    console.error(`\\n${colors.blue}\u2550\u2550\u2550 Auto-fixes Applied \u2550\u2550\u2550${colors.reset}`)\n    autofixes.forEach((fix) => {\n      console.error(`${colors.green}\u2728${colors.reset} ${fix}`)\n    })\n    console.error(\n      `${colors.green}Automatically fixed ${autofixes.length} issue(s) for you!${colors.reset}`,\n    )\n  }\n\n  // Show errors if any\n  if (errors.length > 0) {\n    console.error(\n      `\\n${colors.blue}\u2550\u2550\u2550 Quality Check Summary \u2550\u2550\u2550${colors.reset}`,\n    )\n    errors.forEach((error) => {\n      console.error(`${colors.red}\u274C${colors.reset} ${error}`)\n    })\n\n    console.error(\n      `\\n${colors.red}Found ${errors.length} issue(s) that MUST be fixed!${colors.reset}`,\n    )\n    console.error(\n      `${colors.red}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550${colors.reset}`,\n    )\n    console.error(`${colors.red}\u274C ALL ISSUES ARE BLOCKING \u274C${colors.reset}`)\n    console.error(\n      `${colors.red}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550${colors.reset}`,\n    )\n    console.error(\n      `${colors.red}Fix EVERYTHING above until all checks are \u2705 GREEN${colors.reset}`,\n    )\n  }\n}\n\n/**\n * Main entry point\n */\nasync function main(): Promise<void> {\n  // Load configuration\n  const configPath = path.join(\n    process.cwd(),\n    '.claude/hooks/react-app/hook-config.json',\n  )\n  const config = await loadQualityConfig(configPath)\n  const log = createLogger('INFO', config.debug)\n\n  // Show header\n  const hookVersion = config.fileConfig.version || '1.0.0'\n  console.error('')\n  console.error(`\u269B\uFE0F  React App Quality Check v${hookVersion} - Starting...`)\n  console.error('\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500')\n\n  // Debug: show loaded configuration\n  log.debug(`Loaded config: ${JSON.stringify(config, null, 2)}`)\n\n  // Parse input\n  const input = await parseJsonInput<FileToolInput>()\n  const filePath = input ? extractFilePath(input) : null\n\n  if (!filePath) {\n    log.warning(\n      'No file path found in JSON input. Tool might not be file-related.',\n    )\n    log.debug(`JSON input was: ${JSON.stringify(input)}`)\n    console.error(\n      `\\n${colors.yellow}\uD83D\uDC49 No file to check - tool may not be file-related.${colors.reset}`,\n    )\n    process.exit(HookExitCode.Success)\n  }\n\n  // Check if file exists\n  if (!(await fileExists(filePath))) {\n    log.info(`File does not exist: ${filePath} (may have been deleted)`)\n    console.error(\n      `\\n${colors.yellow}\uD83D\uDC49 File skipped - doesn't exist.${colors.reset}`,\n    )\n    process.exit(HookExitCode.Success)\n  }\n\n  // For non-source files, exit successfully\n  if (!isSourceFile(filePath)) {\n    log.info(`Skipping non-source file: ${filePath}`)\n    console.error(\n      `\\n${colors.yellow}\uD83D\uDC49 File skipped - not a source file.${colors.reset}`,\n    )\n    console.error(\n      `\\n${colors.green}\u2705 No checks needed for ${path.basename(filePath)}${colors.reset}`,\n    )\n    process.exit(HookExitCode.Success)\n  }\n\n  // Update header with file name\n  console.error('')\n  console.error(`\uD83D\uDD0D Validating: ${path.basename(filePath)}`)\n  console.error('\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500')\n  log.info(`Checking: ${filePath}`)\n\n  // Create TypeScript config cache\n  const tsConfigCache = new TypeScriptConfigCache(process.cwd())\n\n  // Run quality checks\n  const checker = new QualityChecker(filePath)\n  const { errors, autofixes } = await checker.checkAll(\n    config,\n    log,\n    tsConfigCache,\n  )\n\n  // Print summary\n  printSummary(errors, autofixes)\n\n  // Separate edited file errors from other issues\n  const editedFileErrors = errors.filter(\n    (e) =>\n      e.includes('edited file') ||\n      e.includes('ESLint found issues') ||\n      e.includes('Prettier formatting issues') ||\n      e.includes('console statements') ||\n      e.includes(\"'as any' usage\") ||\n      e.includes('were auto-fixed'),\n  )\n\n  const dependencyWarnings = errors.filter((e) => !editedFileErrors.includes(e))\n\n  // Exit with appropriate code\n  if (editedFileErrors.length > 0) {\n    // Critical - blocks immediately\n    console.error(\n      `\\n${colors.red}\uD83D\uDED1 FAILED - Fix issues in your edited file! \uD83D\uDED1${colors.reset}`,\n    )\n    console.error(`${colors.cyan}\uD83D\uDCA1 CLAUDE.md CHECK:${colors.reset}`)\n    console.error(\n      `${colors.cyan}  \u2192 What CLAUDE.md pattern would have prevented this?${colors.reset}`,\n    )\n    console.error(\n      `${colors.cyan}  \u2192 Are you following JSDoc batching strategy?${colors.reset}`,\n    )\n    console.error(`${colors.yellow}\uD83D\uDCCB NEXT STEPS:${colors.reset}`)\n    console.error(\n      `${colors.yellow}  1. Fix the issues listed above${colors.reset}`,\n    )\n    console.error(\n      `${colors.yellow}  2. The hook will run again automatically${colors.reset}`,\n    )\n    console.error(\n      `${colors.yellow}  3. Continue with your original task once all checks pass${colors.reset}`,\n    )\n    process.exit(HookExitCode.QualityIssues)\n  } else if (dependencyWarnings.length > 0) {\n    // Warning - shows but doesn't block\n    console.error(\n      `\\n${colors.yellow}\u26A0\uFE0F WARNING - Dependency issues found${colors.reset}`,\n    )\n    console.error(\n      `${colors.yellow}These won't block your progress but should be addressed${colors.reset}`,\n    )\n    console.error(\n      `\\n${colors.green}\u2705 Quality check passed for ${path.basename(filePath)}${colors.reset}`,\n    )\n\n    if (autofixes.length > 0 && config.autofixSilent) {\n      console.error(\n        `\\n${colors.yellow}\uD83D\uDC49 File quality verified. Auto-fixes applied. Continue with your task.${colors.reset}`,\n      )\n    } else {\n      console.error(\n        `\\n${colors.yellow}\uD83D\uDC49 File quality verified. Continue with your task.${colors.reset}`,\n      )\n    }\n    process.exit(HookExitCode.Success)\n  } else {\n    console.error(\n      `\\n${colors.green}\u2705 Quality check passed for ${path.basename(filePath)}${colors.reset}`,\n    )\n\n    if (autofixes.length > 0 && config.autofixSilent) {\n      console.error(\n        `\\n${colors.yellow}\uD83D\uDC49 File quality verified. Auto-fixes applied. Continue with your task.${colors.reset}`,\n      )\n    } else {\n      console.error(\n        `\\n${colors.yellow}\uD83D\uDC49 File quality verified. Continue with your task.${colors.reset}`,\n      )\n    }\n    process.exit(HookExitCode.Success)\n  }\n}\n\n// Handle errors\nprocess.on('unhandledRejection', (error) => {\n  const log = createLogger('INFO', false)\n  log.error(\n    `Unhandled error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n  )\n  process.exit(HookExitCode.GeneralError)\n})\n\n// Run main\nmain().catch((error) => {\n  const log = createLogger('INFO', false)\n  log.error(\n    `Fatal error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n  )\n  process.exit(HookExitCode.GeneralError)\n})\n", "/**\n * Types for Claude Code hook integration\n */\n\n/**\n * Tool names that Claude Code can execute\n */\nexport type ClaudeToolName =\n  | 'Read'\n  | 'Write'\n  | 'Edit'\n  | 'MultiEdit'\n  | 'Bash'\n  | 'LS'\n  | 'Glob'\n  | 'Grep'\n  | 'NotebookEdit'\n  | 'WebFetch'\n  | 'WebSearch'\n  | 'Task'\n  | 'ExitPlanMode'\n  | 'TodoWrite'\n\n/**\n * Base structure for Claude tool input\n */\nexport interface ClaudeToolInput {\n  tool_name: ClaudeToolName\n  tool_input?: Record<string, unknown>\n  tool_result?: unknown\n}\n\n/**\n * File-related tool input\n */\nexport interface FileToolInput extends ClaudeToolInput {\n  tool_input?: {\n    file_path?: string\n    path?: string\n    notebook_path?: string\n    [key: string]: unknown\n  }\n}\n\n/**\n * Exit codes for Claude hooks\n */\nexport enum HookExitCode {\n  Success = 0,\n  GeneralError = 1,\n  QualityIssues = 2,\n}\n", "/**\n * File system utilities\n */\n\nimport { promises as fs } from 'fs'\n\nimport type { ClaudeToolInput } from '../types/claude.js'\n\n/**\n * Parse JSON input from stdin\n */\nexport async function parseJsonInput<\n  T extends ClaudeToolInput,\n>(): Promise<T | null> {\n  let inputData = ''\n\n  // Read from stdin\n  for await (const chunk of process.stdin) {\n    inputData += chunk\n  }\n\n  if (!inputData.trim()) {\n    return null\n  }\n\n  try {\n    return JSON.parse(inputData) as T\n  } catch {\n    return null\n  }\n}\n\n/**\n * Check if file exists\n */\nexport async function fileExists(filePath: string): Promise<boolean> {\n  try {\n    await fs.access(filePath)\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Check if file is a source file\n */\nexport function isSourceFile(filePath: string): boolean {\n  return /\\.(ts|tsx|js|jsx)$/.test(filePath)\n}\n\n/**\n * Read file content\n */\nexport async function readFile(filePath: string): Promise<string> {\n  return fs.readFile(filePath, 'utf8')\n}\n\n/**\n * Write file content\n */\nexport async function writeFile(\n  filePath: string,\n  content: string,\n): Promise<void> {\n  await fs.writeFile(filePath, content, 'utf8')\n}\n\n/**\n * Make file executable\n */\nexport async function makeExecutable(filePath: string): Promise<void> {\n  await fs.chmod(filePath, 0o755)\n}\n", "/**\n * Logging utilities with colored output\n */\n\n// ANSI color codes\nexport const colors = {\n  red: '\\x1b[0;31m',\n  green: '\\x1b[0;32m',\n  yellow: '\\x1b[0;33m',\n  blue: '\\x1b[0;34m',\n  cyan: '\\x1b[0;36m',\n  reset: '\\x1b[0m',\n} as const\n\nexport interface Logger {\n  info: (msg: string) => void\n  error: (msg: string) => void\n  success: (msg: string) => void\n  warning: (msg: string) => void\n  debug: (msg: string) => void\n}\n\n/**\n * Create a logger with optional debug mode\n */\nexport function createLogger(prefix: string, debug = false): Logger {\n  return {\n    info: (msg: string) =>\n      console.error(`${colors.blue}[${prefix}]${colors.reset} ${msg}`),\n    error: (msg: string) =>\n      console.error(`${colors.red}[ERROR]${colors.reset} ${msg}`),\n    success: (msg: string) =>\n      console.error(`${colors.green}[OK]${colors.reset} ${msg}`),\n    warning: (msg: string) =>\n      console.error(`${colors.yellow}[WARN]${colors.reset} ${msg}`),\n    debug: (msg: string) => {\n      if (debug) {\n        console.error(`${colors.cyan}[DEBUG]${colors.reset} ${msg}`)\n      }\n    },\n  }\n}\n", "/**\n * Common code issues checker\n */\n\nimport path from 'path'\n\nimport type { Logger } from '../../utils/logger.js'\nimport type { ResolvedQualityConfig } from '../config.js'\n\nimport { readFile } from '../../utils/file-utils.js'\n\nexport interface CommonIssuesChecker {\n  check(fileType: string): Promise<string[]>\n}\n\nexport async function createCommonIssuesChecker(\n  filePath: string,\n  config: ResolvedQualityConfig,\n  log: Logger,\n): Promise<CommonIssuesChecker> {\n  return {\n    async check(fileType: string): Promise<string[]> {\n      const errors: string[] = []\n      log.info('Checking for common issues...')\n\n      try {\n        const content = await readFile(filePath)\n        const lines = content.split('\\n')\n        let foundIssues = false\n\n        // Check for 'as any' in TypeScript files\n        const asAnyRule = config.fileConfig.rules?.asAny || {}\n        if (\n          (fileType === 'typescript' || fileType === 'component') &&\n          asAnyRule.enabled !== false\n        ) {\n          lines.forEach((line, index) => {\n            if (line.includes('as any')) {\n              const severity = asAnyRule.severity || 'error'\n              const message =\n                asAnyRule.message ||\n                'Prefer proper types or \"as unknown\" for type assertions'\n\n              if (severity === 'error') {\n                errors.push(`Found 'as any' usage in ${filePath} - ${message}`)\n                console.error(`  Line ${index + 1}: ${line.trim()}`)\n                foundIssues = true\n              } else {\n                log.warning(`'as any' usage at line ${index + 1}: ${message}`)\n              }\n            }\n          })\n        }\n\n        // Check for console statements\n        const consoleRule = config.fileConfig.rules?.console || {}\n        let allowConsole = false\n\n        if (consoleRule.enabled === false) {\n          allowConsole = true\n        } else {\n          // Check allowed paths\n          const allowedPaths = consoleRule.allowIn?.paths || []\n          if (allowedPaths.some((allowPath) => filePath.includes(allowPath))) {\n            allowConsole = true\n          }\n\n          // Check allowed file types\n          const allowedFileTypes = consoleRule.allowIn?.fileTypes || []\n          if (allowedFileTypes.includes(fileType)) {\n            allowConsole = true\n          }\n\n          // Check allowed patterns\n          const allowedPatterns = consoleRule.allowIn?.patterns || []\n          const fileName = path.basename(filePath)\n          if (\n            allowedPatterns.some((pattern) => {\n              const regex = new RegExp(pattern.replace(/\\*/g, '.*'))\n              return regex.test(fileName)\n            })\n          ) {\n            allowConsole = true\n          }\n        }\n\n        if (!allowConsole && consoleRule.enabled !== false) {\n          lines.forEach((line, index) => {\n            if (/console\\./.test(line)) {\n              const severity = consoleRule.severity || 'info'\n              const message =\n                consoleRule.message || 'Consider using a logging library'\n\n              if (severity === 'error') {\n                errors.push(\n                  `Found console statements in ${filePath} - ${message}`,\n                )\n                console.error(`  Line ${index + 1}: ${line.trim()}`)\n                foundIssues = true\n              } else {\n                log.warning(`Console usage at line ${index + 1}: ${message}`)\n              }\n            }\n          })\n        }\n\n        // Check for TODO/FIXME comments\n        lines.forEach((line, index) => {\n          if (/TODO|FIXME/.test(line)) {\n            log.warning(`Found TODO/FIXME comment at line ${index + 1}`)\n          }\n        })\n\n        if (!foundIssues) {\n          log.success('No common issues found')\n        }\n      } catch (error) {\n        log.debug(\n          `Common issues check error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        )\n      }\n\n      return errors\n    },\n  }\n}\n", "/**\n * ESLint checker with smart import resolution for TDD\n */\n\nimport path from 'path'\n\nimport type { Logger } from '../../utils/logger.js'\nimport type { ResolvedQualityConfig } from '../config.js'\n\nimport { findProjectRoot } from '../../utils/config-loader.js'\nimport { fileExists, readFile, writeFile } from '../../utils/file-utils.js'\nimport { createDummyFile } from '../dummy-generator.js'\nimport {\n  determineFileExtension,\n  extractImportErrors,\n  parseImportStatement,\n  resolveImportPath,\n} from '../import-parser.js'\n\nexport interface ESLintChecker {\n  check(): Promise<{ errors: string[]; autofixes: string[] }>\n}\n\nexport async function createESLintChecker(\n  filePath: string,\n  config: ResolvedQualityConfig,\n  log: Logger,\n): Promise<ESLintChecker | null> {\n  if (!config.eslintEnabled) {\n    return null\n  }\n\n  const projectRoot = findProjectRoot(path.dirname(filePath))\n  const isTestFile = /\\.(test|spec)\\.(ts|tsx|js|jsx)$/.test(filePath)\n\n  // Try to load ESLint\n  let ESLint: typeof import('eslint').ESLint\n  try {\n    const eslintModule = await import(\n      path.join(projectRoot, 'node_modules', 'eslint', 'lib', 'api.js')\n    )\n    ESLint = eslintModule.ESLint\n  } catch {\n    log.debug('ESLint not found in project - will skip ESLint checks')\n    return null\n  }\n\n  return {\n    async check(): Promise<{ errors: string[]; autofixes: string[] }> {\n      const errors: string[] = []\n      const autofixes: string[] = []\n\n      log.info('Running ESLint...')\n\n      try {\n        const eslint = new ESLint({\n          fix: config.eslintAutofix,\n          cwd: projectRoot,\n        })\n\n        let results = await eslint.lintFiles([filePath])\n        let result = results[0]\n\n        // Handle import errors in test files during TDD\n        if (isTestFile && result?.messages) {\n          const importErrors = extractImportErrors(result.messages)\n          \n          if (importErrors.length > 0) {\n            log.info('Detected import errors in test file, checking if dummy implementations needed...')\n            let dummiesCreated = false\n            \n            try {\n              // Read the test file to find import statements\n              const fileContent = await readFile(filePath)\n              const lines = fileContent.split('\\n')\n              \n              for (const importError of importErrors) {\n                if (!importError.importPath) continue\n                \n                // Find the import statement on the error line\n                const importLine = lines[importError.line - 1]\n                if (!importLine) continue\n                \n                const parsedImport = parseImportStatement(importLine)\n                if (!parsedImport || !parsedImport.isRelative) continue\n                \n                // Resolve the import path\n                const resolvedPath = resolveImportPath(\n                  parsedImport.importPath,\n                  filePath,\n                  projectRoot,\n                )\n                \n                // Determine file extension\n                const ext = determineFileExtension(\n                  resolvedPath,\n                  parsedImport.isTypeOnly,\n                  filePath,\n                )\n                \n                const fullPath = path.join(projectRoot, resolvedPath + ext)\n                \n                // Check if file exists\n                if (!(await fileExists(fullPath))) {\n                  // Create dummy implementation\n                  const created = await createDummyFile(\n                    fullPath,\n                    parsedImport,\n                    (msg) => log.info(msg),\n                  )\n                  \n                  if (created) {\n                    dummiesCreated = true\n                  }\n                }\n              }\n              \n              // Re-lint if we created any dummy files\n              if (dummiesCreated) {\n                log.info('Re-running ESLint after creating dummy implementations...')\n                results = await eslint.lintFiles([filePath])\n                result = results[0]\n              }\n            } catch (error) {\n              log.debug(\n                `Error handling import errors: ${error instanceof Error ? error.message : 'Unknown error'}`,\n              )\n            }\n          }\n        }\n\n        if (result && (result.errorCount > 0 || result.warningCount > 0)) {\n          if (config.eslintAutofix) {\n            log.warning('ESLint issues found, attempting auto-fix...')\n\n            // Write the fixed output\n            if (result.output) {\n              await writeFile(filePath, result.output)\n\n              // Re-lint to see if issues remain\n              const resultsAfterFix = await eslint.lintFiles([filePath])\n              const resultAfterFix = resultsAfterFix[0]\n\n              if (\n                resultAfterFix &&\n                resultAfterFix.errorCount === 0 &&\n                resultAfterFix.warningCount === 0\n              ) {\n                log.success('ESLint auto-fixed all issues!')\n                if (config.autofixSilent) {\n                  autofixes.push('ESLint auto-fixed formatting/style issues')\n                } else {\n                  errors.push(\n                    'ESLint issues were auto-fixed - verify the changes',\n                  )\n                }\n              } else {\n                errors.push(\n                  `ESLint found issues that couldn't be auto-fixed in ${filePath}`,\n                )\n                const formatter = await eslint.loadFormatter('stylish')\n                const output = await formatter.format(resultsAfterFix)\n                console.error(output)\n              }\n            } else {\n              errors.push(`ESLint found issues in ${filePath}`)\n              const formatter = await eslint.loadFormatter('stylish')\n              const output = await formatter.format(results)\n              console.error(output)\n            }\n          } else {\n            errors.push(`ESLint found issues in ${filePath}`)\n            const formatter = await eslint.loadFormatter('stylish')\n            const output = await formatter.format(results)\n            console.error(output)\n          }\n        } else {\n          log.success('ESLint passed')\n        }\n      } catch (error) {\n        log.debug(\n          `ESLint check error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        )\n      }\n\n      return { errors, autofixes }\n    },\n  }\n}\n", "/**\n * Configuration loading utilities\n */\n\nimport { promises as fs, statSync } from 'fs'\nimport path from 'path'\n\n/**\n * Load JSON configuration file with environment variable overrides\n */\nexport async function loadConfig<T extends Record<string, unknown>>(\n  configPath: string,\n  envOverrides: Record<string, (value: string | undefined) => unknown> = {},\n): Promise<T | null> {\n  let fileConfig: T | null = null\n\n  // Try to load file config\n  try {\n    const content = await fs.readFile(configPath, 'utf8')\n    fileConfig = JSON.parse(content) as T\n  } catch {\n    // Config file not found or invalid\n    return null\n  }\n\n  // Apply environment variable overrides\n  const config = { ...fileConfig }\n\n  for (const [envKey, transformer] of Object.entries(envOverrides)) {\n    const envValue = process.env[envKey]\n    if (envValue !== undefined) {\n      const transformed = transformer(envValue)\n      if (transformed !== undefined) {\n        // Apply the transformed value to the config\n        // This is a simplified version - in real implementation\n        // we'd need to handle nested paths\n        Object.assign(config, transformed)\n      }\n    }\n  }\n\n  return config\n}\n\n/**\n * Find project root by looking for package.json\n */\nexport function findProjectRoot(startPath: string): string {\n  let currentPath = startPath\n  while (currentPath !== '/') {\n    try {\n      const stat = statSync(path.join(currentPath, 'package.json'))\n      if (stat.isFile()) {\n        return currentPath\n      }\n    } catch {\n      // Continue searching\n    }\n    currentPath = path.dirname(currentPath)\n  }\n  return process.cwd()\n}\n\n/**\n * Parse boolean environment variable\n */\nexport function parseBoolean(\n  value: string | undefined,\n  defaultValue = false,\n): boolean {\n  if (value === undefined) return defaultValue\n  return value !== 'false'\n}\n\n/**\n * Parse integer environment variable\n */\nexport function parseInteger(\n  value: string | undefined,\n  defaultValue = 0,\n): number {\n  if (value === undefined) return defaultValue\n  const parsed = parseInt(value, 10)\n  return isNaN(parsed) ? defaultValue : parsed\n}\n", "/**\n * Generate dummy implementations for missing imports during TDD\n */\n\nimport { promises as fs } from 'fs'\nimport path from 'path'\n\nimport type { ParsedImport } from './import-parser.js'\n\n/**\n * Generate appropriate dummy content based on import details\n */\nexport function generateDummyContent(parsedImport: ParsedImport): string {\n  const { defaultImport, namedImports, namespace, isTypeOnly } = parsedImport\n  const lines: string[] = []\n  \n  // Add header comment\n  lines.push('/**')\n  lines.push(' * Auto-generated dummy implementation for TDD')\n  lines.push(' * This file was created to satisfy ESLint during test-driven development.')\n  lines.push(' * Replace this with your actual implementation.')\n  lines.push(' */')\n  lines.push('')\n  \n  if (isTypeOnly) {\n    // Generate type definitions\n    if (defaultImport) {\n      lines.push(`export type ${defaultImport} = {`)\n      lines.push('  // TODO: Add actual type definition')\n      lines.push('  _dummy: true')\n      lines.push('}')\n      lines.push('')\n    }\n    \n    for (const namedImport of namedImports) {\n      if (isInterfaceOrTypeName(namedImport)) {\n        lines.push(`export interface ${namedImport} {`)\n        lines.push('  // TODO: Add actual interface definition')\n        lines.push('  _dummy: true')\n        lines.push('}')\n      } else {\n        lines.push(`export type ${namedImport} = any // TODO: Add actual type`)\n      }\n      lines.push('')\n    }\n  } else {\n    // Generate runtime implementations\n    if (defaultImport) {\n      if (isComponentName(defaultImport)) {\n        lines.push(generateReactComponent(defaultImport, true))\n      } else {\n        lines.push(generateFunction(defaultImport, true))\n      }\n      lines.push('')\n    }\n    \n    for (const namedImport of namedImports) {\n      if (isComponentName(namedImport)) {\n        lines.push(generateReactComponent(namedImport, false))\n      } else if (isConstantName(namedImport)) {\n        lines.push(generateConstant(namedImport))\n      } else {\n        lines.push(generateFunction(namedImport, false))\n      }\n      lines.push('')\n    }\n    \n    if (namespace) {\n      lines.push(`const ${namespace} = {`)\n      lines.push('  // TODO: Add namespace exports')\n      lines.push('}')\n      lines.push('')\n      lines.push(`export default ${namespace}`)\n    }\n  }\n  \n  return lines.join('\\n')\n}\n\n/**\n * Check if name is likely a React component (PascalCase)\n */\nfunction isComponentName(name: string): boolean {\n  return /^[A-Z][a-zA-Z0-9]*$/.test(name)\n}\n\n/**\n * Check if name is likely a constant (UPPER_CASE)\n */\nfunction isConstantName(name: string): boolean {\n  return /^[A-Z_][A-Z0-9_]*$/.test(name)\n}\n\n/**\n * Check if name is likely an interface or type (starts with I or ends with Type)\n */\nfunction isInterfaceOrTypeName(name: string): boolean {\n  return /^I[A-Z]/.test(name) || /Type$/.test(name) || isComponentName(name)\n}\n\n/**\n * Generate a React component stub\n */\nfunction generateReactComponent(name: string, isDefault: boolean): string {\n  const lines = [\n    `${isDefault ? 'export default ' : 'export '}function ${name}(props: any) {`,\n    `  throw new Error('${name} component not implemented yet')`,\n    `  // TODO: Implement ${name} component`,\n    `  // return <div>${name}</div>`,\n    '}',\n  ]\n  return lines.join('\\n')\n}\n\n/**\n * Generate a function stub\n */\nfunction generateFunction(name: string, isDefault: boolean): string {\n  const lines = [\n    `${isDefault ? 'export default ' : 'export '}function ${name}(...args: any[]): any {`,\n    `  throw new Error('${name} not implemented yet')`,\n    '  // TODO: Implement this function',\n    '}',\n  ]\n  return lines.join('\\n')\n}\n\n/**\n * Generate a constant stub\n */\nfunction generateConstant(name: string): string {\n  return `export const ${name} = {} as any // TODO: Add actual value`\n}\n\n/**\n * Create dummy file with appropriate content\n */\nexport async function createDummyFile(\n  filePath: string,\n  parsedImport: ParsedImport,\n  log?: (message: string) => void,\n): Promise<boolean> {\n  try {\n    // Ensure directory exists\n    const dir = path.dirname(filePath)\n    await fs.mkdir(dir, { recursive: true })\n    \n    // Check if file already exists\n    try {\n      await fs.access(filePath)\n      return false // File already exists, don't overwrite\n    } catch {\n      // File doesn't exist, proceed\n    }\n    \n    // Generate content\n    const content = generateDummyContent(parsedImport)\n    \n    // Write file\n    await fs.writeFile(filePath, content, 'utf8')\n    \n    if (log) {\n      log(`\uD83D\uDCDD Created dummy implementation: ${path.relative(process.cwd(), filePath)}`)\n      log('   (Replace with actual implementation)')\n    }\n    \n    return true\n  } catch (error) {\n    if (log) {\n      log(`Failed to create dummy file: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n    return false\n  }\n}", "/**\n * Import parser for analyzing import statements and ESLint errors\n */\n\nimport path from 'path'\n\nexport interface ParsedImport {\n  importPath: string\n  isRelative: boolean\n  isTypeOnly: boolean\n  defaultImport?: string\n  namedImports: string[]\n  namespace?: string\n  rawStatement: string\n}\n\nexport interface ImportError {\n  message: string\n  importPath?: string\n  line: number\n  column: number\n}\n\n/**\n * Parse import statement to extract details\n */\nexport function parseImportStatement(statement: string): ParsedImport | null {\n  // Remove comments and extra whitespace\n  const cleaned = statement.trim().replace(/\\/\\*[\\s\\S]*?\\*\\//g, '').replace(/\\/\\/.*/g, '')\n  \n  // Match various import patterns\n  const importRegex = /^import\\s+(?:type\\s+)?(?:(\\w+)(?:\\s*,\\s*)?)?(?:\\{([^}]+)\\})?\\s*(?:,\\s*\\*\\s+as\\s+(\\w+))?\\s*from\\s*['\"]([^'\"]+)['\"]/\n  const namespaceRegex = /^import\\s+(?:type\\s+)?\\*\\s+as\\s+(\\w+)\\s+from\\s*['\"]([^'\"]+)['\"]/\n  \n  let match = importRegex.exec(cleaned)\n  let isNamespace = false\n  \n  if (!match) {\n    match = namespaceRegex.exec(cleaned)\n    isNamespace = true\n  }\n  \n  if (!match) {\n    return null\n  }\n  \n  if (isNamespace) {\n    const [, namespace, importPath] = match\n    return {\n      importPath,\n      isRelative: importPath.startsWith('.'),\n      isTypeOnly: cleaned.includes('import type'),\n      namedImports: [],\n      namespace,\n      rawStatement: statement,\n    }\n  }\n  \n  const [, defaultImport, namedImportsStr, namespace, importPath] = match\n  \n  // Parse named imports\n  const namedImports: string[] = []\n  if (namedImportsStr) {\n    namedImportsStr.split(',').forEach(imp => {\n      const trimmed = imp.trim()\n      if (trimmed) {\n        // Handle renamed imports like \"foo as bar\"\n        const renamed = trimmed.split(/\\s+as\\s+/)\n        namedImports.push(renamed[0].trim())\n      }\n    })\n  }\n  \n  return {\n    importPath,\n    isRelative: importPath.startsWith('.'),\n    isTypeOnly: cleaned.includes('import type'),\n    defaultImport: defaultImport?.trim(),\n    namedImports,\n    namespace: namespace?.trim(),\n    rawStatement: statement,\n  }\n}\n\n/**\n * Extract import errors from ESLint messages\n */\nexport function extractImportErrors(eslintMessages: Array<{\n  message?: string\n  ruleId?: string | null\n  line?: number\n  column?: number\n}>): ImportError[] {\n  const importErrors: ImportError[] = []\n  \n  for (const message of eslintMessages) {\n    // Check for various import-related error messages\n    if (\n      message.message?.includes('Unable to resolve') ||\n      message.message?.includes('Cannot find module') ||\n      message.message?.includes('Could not find a declaration file') ||\n      message.ruleId === 'import/no-unresolved' ||\n      message.ruleId === 'import/named'\n    ) {\n      // Try to extract the import path from the message\n      const pathMatch = message.message?.match(/['\"]([^'\"]+)['\"]/)\n      \n      importErrors.push({\n        message: message.message || 'Import error',\n        importPath: pathMatch?.[1],\n        line: message.line || 0,\n        column: message.column || 0,\n      })\n    }\n  }\n  \n  return importErrors\n}\n\n/**\n * Determine the file extension to use for the dummy file\n */\nexport function determineFileExtension(\n  importPath: string,\n  isTypeOnly: boolean,\n  fileContext: string,\n): string {\n  // If import path already has extension, use it\n  if (/\\.[jt]sx?$/.test(importPath)) {\n    return ''\n  }\n  \n  // For type-only imports, prefer .ts\n  if (isTypeOnly) {\n    return '.ts'\n  }\n  \n  // If importing from a test file, check if it's likely a React component\n  const importName = importPath.split('/').pop() || ''\n  if (\n    /^[A-Z]/.test(importName) || // PascalCase suggests component\n    importPath.includes('components') ||\n    fileContext.includes('.tsx')\n  ) {\n    return '.tsx'\n  }\n  \n  // Default to .ts for TypeScript projects\n  return '.ts'\n}\n\n/**\n * Resolve relative import path to absolute file path\n */\nexport function resolveImportPath(\n  importPath: string,\n  currentFile: string,\n  projectRoot: string,\n): string {\n  if (!importPath.startsWith('.')) {\n    // Not a relative import, might be a module or alias\n    return importPath\n  }\n  \n  const currentDir = path.dirname(currentFile)\n  const resolved = path.resolve(currentDir, importPath)\n  \n  // Make relative to project root for cleaner paths\n  return path.relative(projectRoot, resolved)\n}", "/**\n * Prettier formatter checker\n */\n\nimport path from 'path'\n\nimport type { Logger } from '../../utils/logger.js'\nimport type { ResolvedQualityConfig } from '../config.js'\n\nimport { findProjectRoot } from '../../utils/config-loader.js'\nimport { readFile, writeFile } from '../../utils/file-utils.js'\n\nexport interface PrettierChecker {\n  check(): Promise<{ errors: string[]; autofixes: string[] }>\n}\n\nexport async function createPrettierChecker(\n  filePath: string,\n  config: ResolvedQualityConfig,\n  log: Logger,\n): Promise<PrettierChecker | null> {\n  if (!config.prettierEnabled) {\n    return null\n  }\n\n  const projectRoot = findProjectRoot(path.dirname(filePath))\n\n  // Try to load Prettier\n  let prettier: typeof import('prettier')\n  try {\n    const prettierPath = path.join(projectRoot, 'node_modules', 'prettier', 'index.cjs')\n    const prettierModule = await import(prettierPath)\n    // Handle CommonJS default export\n    if ('default' in prettierModule && prettierModule.default) {\n      prettier = prettierModule.default as typeof import('prettier')\n    } else {\n      prettier = prettierModule as typeof import('prettier')\n    }\n  } catch (error) {\n    log.debug(`Prettier not found in project - will skip Prettier checks. Error: ${error}`)\n    return null\n  }\n\n  return {\n    async check(): Promise<{ errors: string[]; autofixes: string[] }> {\n      const errors: string[] = []\n      const autofixes: string[] = []\n\n      log.info('Running Prettier check...')\n\n      try {\n        const fileContent = await readFile(filePath)\n        const prettierConfig = await prettier.resolveConfig(filePath)\n\n        const isFormatted = await prettier.check(fileContent, {\n          ...prettierConfig,\n          filepath: filePath,\n        })\n\n        if (!isFormatted) {\n          if (config.prettierAutofix) {\n            log.warning('Prettier formatting issues found, auto-fixing...')\n\n            const formatted = await prettier.format(fileContent, {\n              ...prettierConfig,\n              filepath: filePath,\n            })\n\n            await writeFile(filePath, formatted)\n            log.success('Prettier auto-formatted the file!')\n\n            if (config.autofixSilent) {\n              autofixes.push('Prettier auto-formatted the file')\n            } else {\n              errors.push(\n                'Prettier formatting was auto-fixed - verify the changes',\n              )\n            }\n          } else {\n            errors.push(`Prettier formatting issues in ${filePath}`)\n            console.error('Run prettier --write to fix')\n          }\n        } else {\n          log.success('Prettier formatting correct')\n        }\n      } catch (error) {\n        log.debug(\n          `Prettier check error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        )\n      }\n\n      return { errors, autofixes }\n    },\n  }\n}\n", "/**\n * TypeScript compilation checker with TDD support\n */\n\nimport { existsSync } from 'fs'\nimport path from 'path'\n\nimport type { Logger } from '../../utils/logger.js'\nimport type { ResolvedQualityConfig } from '../config.js'\n\nimport { findProjectRoot } from '../../utils/config-loader.js'\nimport { fileExists, readFile } from '../../utils/file-utils.js'\nimport { createDummyFile } from '../dummy-generator.js'\nimport {\n  determineFileExtension,\n  parseImportStatement,\n  resolveImportPath,\n} from '../import-parser.js'\nimport { TypeScriptConfigCache } from '../typescript-cache.js'\n\nexport interface TypeScriptChecker {\n  check(): Promise<string[]>\n}\n\nexport async function createTypeScriptChecker(\n  filePath: string,\n  config: ResolvedQualityConfig,\n  log: Logger,\n  tsConfigCache: TypeScriptConfigCache,\n): Promise<TypeScriptChecker | null> {\n  if (!config.typescriptEnabled) {\n    return null\n  }\n\n  // Skip TypeScript checking for JavaScript files in hook directories\n  if (filePath.endsWith('.js') && filePath.includes('.claude/hooks/')) {\n    log.debug('Skipping TypeScript check for JavaScript hook file')\n    return null\n  }\n\n  const projectRoot = findProjectRoot(path.dirname(filePath))\n  log.debug(`Project root: ${projectRoot}`)\n  log.debug(`Looking for TypeScript at: ${path.join(projectRoot, 'node_modules', 'typescript')}`)\n\n  // Try to load TypeScript\n  let ts: typeof import('typescript')\n  try {\n    ts = await import(path.join(projectRoot, 'node_modules', 'typescript', 'lib', 'typescript.js'))\n  } catch (error) {\n    log.debug(`TypeScript not found in project - will skip TypeScript checks. Error: ${error}`)\n    return null\n  }\n\n  const isTestFile = /\\.(test|spec)\\.(ts|tsx|js|jsx)$/.test(filePath)\n  \n  return {\n    async check(): Promise<string[]> {\n      const errors: string[] = []\n      log.info('Running TypeScript compilation check...')\n\n      try {\n        // Get intelligent config for this file\n        const configPath = tsConfigCache.getTsConfigForFile(filePath)\n\n        if (!existsSync(configPath)) {\n          log.debug(`No TypeScript config found: ${configPath}`)\n          return errors\n        }\n\n        log.debug(\n          `Using TypeScript config: ${path.basename(configPath)} for ${path.relative(projectRoot, filePath)}`,\n        )\n\n        const configFile = ts.readConfigFile(configPath, ts.sys.readFile)\n        const parsedConfig = ts.parseJsonConfigFileContent(\n          configFile.config,\n          ts.sys,\n          path.dirname(configPath),\n        )\n\n        // Create program with just the edited file\n        log.debug(`TypeScript checking edited file only`)\n        let program = ts.createProgram([filePath], parsedConfig.options)\n        let diagnostics = ts.getPreEmitDiagnostics(program)\n        \n        // Handle import errors in test files during TDD\n        if (isTestFile && diagnostics.length > 0) {\n          const importDiagnostics = diagnostics.filter(\n            d => d.code === 2307 || // Cannot find module\n                 d.code === 2792    // Cannot find module (type declarations)\n          )\n          \n          if (importDiagnostics.length > 0) {\n            log.info('Detected import errors in test file, creating dummy implementations...')\n            let dummiesCreated = false\n            \n            try {\n              // Read the test file to analyze imports\n              const fileContent = await readFile(filePath)\n              const lines = fileContent.split('\\n')\n              \n              for (const diagnostic of importDiagnostics) {\n                if (!diagnostic.file || !diagnostic.start) continue\n                \n                // Get the line number\n                const { line } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start)\n                \n                // Find the import statement\n                const importLine = lines[line]\n                if (!importLine) continue\n                \n                const parsedImport = parseImportStatement(importLine)\n                if (!parsedImport || !parsedImport.isRelative) continue\n                \n                // Resolve the import path\n                const resolvedPath = resolveImportPath(\n                  parsedImport.importPath,\n                  filePath,\n                  projectRoot,\n                )\n                \n                // Determine file extension\n                const ext = determineFileExtension(\n                  resolvedPath,\n                  parsedImport.isTypeOnly,\n                  filePath,\n                )\n                \n                const fullPath = path.join(projectRoot, resolvedPath + ext)\n                \n                // Check if file exists\n                if (!(await fileExists(fullPath))) {\n                  // Create dummy implementation\n                  const created = await createDummyFile(\n                    fullPath,\n                    parsedImport,\n                    (msg) => log.info(msg),\n                  )\n                  \n                  if (created) {\n                    dummiesCreated = true\n                  }\n                }\n              }\n              \n              // Re-check TypeScript if we created any dummy files\n              if (dummiesCreated) {\n                log.info('Re-running TypeScript check after creating dummy implementations...')\n                program = ts.createProgram([filePath], parsedConfig.options)\n                diagnostics = ts.getPreEmitDiagnostics(program)\n              }\n            } catch (error) {\n              log.debug(\n                `Error handling import errors: ${error instanceof Error ? error.message : 'Unknown error'}`,\n              )\n            }\n          }\n        }\n\n        // Group diagnostics by file\n        const diagnosticsByFile = new Map<string, (typeof diagnostics)[0][]>()\n        for (const d of diagnostics) {\n          if (d.file) {\n            const fileName = d.file.fileName\n            if (!diagnosticsByFile.has(fileName)) {\n              diagnosticsByFile.set(fileName, [])\n            }\n            diagnosticsByFile.get(fileName)!.push(d)\n          }\n        }\n\n        // Report edited file first\n        const editedFileDiagnostics = diagnosticsByFile.get(filePath) || []\n        if (editedFileDiagnostics.length > 0) {\n          errors.push(\n            `TypeScript errors in edited file (using ${path.basename(configPath)})`,\n          )\n          for (const diagnostic of editedFileDiagnostics) {\n            const message = ts.flattenDiagnosticMessageText(\n              diagnostic.messageText,\n              '\\n',\n            )\n            const { line, character } = diagnostic.file\n              ? diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start!)\n              : { line: 0, character: 0 }\n            console.error(\n              `  \u274C ${diagnostic.file?.fileName || 'unknown'}:${line + 1}:${character + 1} - ${message}`,\n            )\n          }\n        }\n\n        // Report dependencies separately (as warnings, not errors) - only if enabled\n        if (config.showDependencyErrors) {\n          let hasDepErrors = false\n          diagnosticsByFile.forEach((diags, fileName) => {\n            if (fileName !== filePath) {\n              if (!hasDepErrors) {\n                console.error(\n                  '\\n[DEPENDENCY ERRORS] Files imported by your edited file:',\n                )\n                hasDepErrors = true\n              }\n              console.error(`  \u26A0\uFE0F ${fileName}:`)\n              for (const diagnostic of diags) {\n                const message = ts.flattenDiagnosticMessageText(\n                  diagnostic.messageText,\n                  '\\n',\n                )\n                const { line, character } = diagnostic.file\n                  ? diagnostic.file.getLineAndCharacterOfPosition(\n                      diagnostic.start!,\n                    )\n                  : { line: 0, character: 0 }\n                console.error(\n                  `     Line ${line + 1}:${character + 1} - ${message}`,\n                )\n              }\n            }\n          })\n        }\n\n        if (diagnostics.length === 0) {\n          log.success('TypeScript compilation passed')\n        }\n      } catch (error) {\n        log.debug(\n          `TypeScript check error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        )\n      }\n\n      return errors\n    },\n  }\n}\n", "/**\n * Configuration management for quality check hook\n */\n\nimport { promises as fs } from 'fs'\n\nimport type { QualityCheckConfig } from '../types/config.js'\n\nimport { parseBoolean } from '../utils/config-loader.js'\n\nexport interface ResolvedQualityConfig {\n  typescriptEnabled: boolean\n  showDependencyErrors: boolean\n  eslintEnabled: boolean\n  eslintAutofix: boolean\n  prettierEnabled: boolean\n  prettierAutofix: boolean\n  autofixSilent: boolean\n  debug: boolean\n  ignorePatterns: string[]\n  fileConfig: QualityCheckConfig\n}\n\n/**\n * Load configuration from JSON file with environment variable overrides\n */\nexport async function loadQualityConfig(\n  configPath: string,\n): Promise<ResolvedQualityConfig> {\n  let fileConfig: QualityCheckConfig = {}\n\n  try {\n    const content = await fs.readFile(configPath, 'utf8')\n    fileConfig = JSON.parse(content) as QualityCheckConfig\n  } catch {\n    // Config file not found or invalid, use defaults\n  }\n\n  return {\n    // TypeScript settings\n    typescriptEnabled:\n      process.env.CLAUDE_HOOKS_TYPESCRIPT_ENABLED !== undefined\n        ? parseBoolean(process.env.CLAUDE_HOOKS_TYPESCRIPT_ENABLED, true)\n        : (fileConfig.typescript?.enabled ?? true),\n\n    showDependencyErrors:\n      process.env.CLAUDE_HOOKS_SHOW_DEPENDENCY_ERRORS !== undefined\n        ? parseBoolean(process.env.CLAUDE_HOOKS_SHOW_DEPENDENCY_ERRORS)\n        : (fileConfig.typescript?.showDependencyErrors ?? false),\n\n    // ESLint settings\n    eslintEnabled:\n      process.env.CLAUDE_HOOKS_ESLINT_ENABLED !== undefined\n        ? parseBoolean(process.env.CLAUDE_HOOKS_ESLINT_ENABLED, true)\n        : (fileConfig.eslint?.enabled ?? true),\n\n    eslintAutofix:\n      process.env.CLAUDE_HOOKS_ESLINT_AUTOFIX !== undefined\n        ? parseBoolean(process.env.CLAUDE_HOOKS_ESLINT_AUTOFIX)\n        : (fileConfig.eslint?.autofix ?? false),\n\n    // Prettier settings\n    prettierEnabled:\n      process.env.CLAUDE_HOOKS_PRETTIER_ENABLED !== undefined\n        ? parseBoolean(process.env.CLAUDE_HOOKS_PRETTIER_ENABLED, true)\n        : (fileConfig.prettier?.enabled ?? true),\n\n    prettierAutofix:\n      process.env.CLAUDE_HOOKS_PRETTIER_AUTOFIX !== undefined\n        ? parseBoolean(process.env.CLAUDE_HOOKS_PRETTIER_AUTOFIX)\n        : (fileConfig.prettier?.autofix ?? false),\n\n    // General settings\n    autofixSilent:\n      process.env.CLAUDE_HOOKS_AUTOFIX_SILENT !== undefined\n        ? parseBoolean(process.env.CLAUDE_HOOKS_AUTOFIX_SILENT)\n        : (fileConfig.general?.autofixSilent ?? false),\n\n    debug:\n      process.env.CLAUDE_HOOKS_DEBUG !== undefined\n        ? parseBoolean(process.env.CLAUDE_HOOKS_DEBUG)\n        : (fileConfig.general?.debug ?? false),\n\n    // Ignore patterns\n    ignorePatterns: fileConfig.ignore?.patterns || [],\n\n    // Store the full config for rule access\n    fileConfig,\n  }\n}\n", "/**\n * TypeScript configuration cache management\n */\n\nimport crypto from 'crypto'\nimport { existsSync, readFileSync, writeFileSync } from 'fs'\nimport path from 'path'\n\nimport { findProjectRoot } from '../utils/config-loader.js'\n\ninterface CacheData {\n  hashes: Record<string, string>\n  mappings: Record<string, { configPath: string; excludes: string[] }>\n}\n\n/**\n * Intelligent TypeScript Config Cache with checksum validation\n * Handles multiple tsconfig files and maps files to appropriate configs\n */\nexport class TypeScriptConfigCache {\n  private cacheFile: string\n  private cache: CacheData\n  private projectRoot: string\n\n  constructor(hookDir: string) {\n    this.projectRoot = findProjectRoot(hookDir)\n    // Store cache in a location that won't interfere with Turborepo\n    // Using .claude directory which is likely gitignored\n    this.cacheFile = path.join(hookDir, 'tsconfig-cache.json')\n    this.cache = { hashes: {}, mappings: {} }\n    this.loadCache()\n  }\n\n  /**\n   * Get config hash for cache validation\n   */\n  private getConfigHash(configPath: string): string | null {\n    try {\n      const content = readFileSync(configPath, 'utf8')\n      return crypto.createHash('sha256').update(content).digest('hex')\n    } catch {\n      return null\n    }\n  }\n\n  /**\n   * Find all tsconfig files in project\n   */\n  private findTsConfigFiles(): string[] {\n    const configs: string[] = []\n\n    // Common config files to check\n    const commonConfigs = [\n      'tsconfig.json',\n      'tsconfig.webview.json',\n      'tsconfig.test.json',\n      'tsconfig.node.json',\n    ]\n\n    for (const config of commonConfigs) {\n      const configPath = path.join(this.projectRoot, config)\n      if (existsSync(configPath)) {\n        configs.push(configPath)\n      }\n    }\n\n    return configs\n  }\n\n  /**\n   * Check if cache is valid by comparing config hashes\n   * This complements Turborepo's caching by providing finer-grained\n   * invalidation for TypeScript config resolution\n   */\n  isValid(): boolean {\n    const configFiles = this.findTsConfigFiles()\n\n    // Check if we have the same number of configs\n    if (Object.keys(this.cache.hashes).length !== configFiles.length) {\n      return false\n    }\n\n    // Check each config hash\n    for (const configPath of configFiles) {\n      const currentHash = this.getConfigHash(configPath)\n      if (currentHash !== this.cache.hashes[configPath]) {\n        return false\n      }\n    }\n\n    // In a Turborepo environment, also consider if Turborepo's\n    // cache has been invalidated (tsconfig files are in globalDependencies)\n    return true\n  }\n\n  /**\n   * Rebuild cache by parsing all configs and creating file mappings\n   */\n  rebuild(): void {\n    this.cache = { hashes: {}, mappings: {} }\n\n    // Process configs in priority order (most specific first)\n    const configPriority = [\n      'tsconfig.webview.json',\n      'tsconfig.test.json',\n      'tsconfig.json',\n    ]\n\n    for (const configName of configPriority) {\n      const configPath = path.join(this.projectRoot, configName)\n      if (!existsSync(configPath)) {\n        continue\n      }\n\n      // Store hash for validation\n      const hash = this.getConfigHash(configPath)\n      if (hash) {\n        this.cache.hashes[configPath] = hash\n      }\n\n      try {\n        const configContent = readFileSync(configPath, 'utf8')\n        const config = JSON.parse(configContent)\n\n        // Build file pattern mappings\n        if (config.include) {\n          for (const pattern of config.include) {\n            // Only set if not already mapped by a more specific config\n            if (!this.cache.mappings[pattern]) {\n              this.cache.mappings[pattern] = {\n                configPath,\n                excludes: config.exclude || [],\n              }\n            }\n          }\n        }\n      } catch {\n        // Skip invalid configs\n      }\n    }\n\n    this.saveCache()\n  }\n\n  /**\n   * Load cache from disk\n   */\n  private loadCache(): void {\n    try {\n      const cacheContent = readFileSync(this.cacheFile, 'utf8')\n      this.cache = JSON.parse(cacheContent) as CacheData\n    } catch {\n      // Cache doesn't exist or is invalid, will rebuild\n      this.cache = { hashes: {}, mappings: {} }\n    }\n  }\n\n  /**\n   * Save cache to disk\n   */\n  private saveCache(): void {\n    try {\n      writeFileSync(this.cacheFile, JSON.stringify(this.cache, null, 2))\n    } catch {\n      // Ignore cache save errors\n    }\n  }\n\n  /**\n   * Get appropriate tsconfig for a file\n   */\n  getTsConfigForFile(filePath: string): string {\n    // Ensure cache is valid\n    if (!this.isValid()) {\n      this.rebuild()\n    }\n\n    const relativePath = path.relative(this.projectRoot, filePath)\n\n    // Check cached mappings\n    const sortedMappings = Object.entries(this.cache.mappings).sort(\n      ([a], [b]) => {\n        const aSpecificity = a.split('/').length + (a.includes('**') ? 0 : 10)\n        const bSpecificity = b.split('/').length + (b.includes('**') ? 0 : 10)\n        return bSpecificity - aSpecificity\n      },\n    )\n\n    for (const [pattern, mapping] of sortedMappings) {\n      if (this.matchesPattern(relativePath, pattern)) {\n        // Check if file is excluded\n        let isExcluded = false\n        for (const exclude of mapping.excludes) {\n          if (this.matchesPattern(relativePath, exclude)) {\n            isExcluded = true\n            break\n          }\n        }\n\n        if (!isExcluded) {\n          return mapping.configPath\n        }\n      }\n    }\n\n    // Fast heuristics for common cases\n    if (relativePath.includes('webview/')) {\n      const webviewConfig = path.join(this.projectRoot, 'tsconfig.webview.json')\n      if (existsSync(webviewConfig)) {\n        return webviewConfig\n      }\n    }\n\n    if (relativePath.includes('.test.') || relativePath.includes('.spec.')) {\n      const testConfig = path.join(this.projectRoot, 'tsconfig.test.json')\n      if (existsSync(testConfig)) {\n        return testConfig\n      }\n    }\n\n    // Default fallback\n    return path.join(this.projectRoot, 'tsconfig.json')\n  }\n\n  /**\n   * Simple pattern matching for file paths\n   */\n  private matchesPattern(filePath: string, pattern: string): boolean {\n    if (pattern.endsWith('/**/*')) {\n      const baseDir = pattern.slice(0, -5)\n      return filePath.startsWith(baseDir)\n    }\n\n    // Convert glob to regex\n    const regexPattern = pattern\n      .replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&')\n      .replace(/\\*\\*/g, '\uD83C\uDF1F')\n      .replace(/\\*/g, '[^/]*')\n      .replace(/\uD83C\uDF1F/g, '.*')\n      .replace(/\\?/g, '.')\n\n    const regex = new RegExp(`^${regexPattern}$`)\n    return regex.test(filePath)\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_path", "HookExitCode", "fs", "path", "import_path", "import_fs", "import_path", "path", "import_fs", "import_path", "path", "fs", "import_path", "namespace", "importPath", "path", "path", "import_path", "path", "import_fs", "import_path", "path", "import_fs", "fs", "import_fs", "import_path", "path", "crypto", "path"]
}
