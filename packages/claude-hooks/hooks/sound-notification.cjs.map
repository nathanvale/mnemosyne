{
  "version": 3,
  "sources": ["../src/sound-notification/index.ts", "../src/types/claude.ts", "../src/utils/file-utils.ts", "../src/utils/logger.ts", "../src/sound-notification/config.ts", "../src/utils/config-loader.ts"],
  "sourcesContent": ["/**\n * Task Completion Sound Hook\n * Plays notification sounds when tasks complete successfully\n */\n\nimport { execSync } from 'child_process'\nimport { existsSync } from 'fs'\nimport path from 'path'\n\nimport type { ClaudeToolInput } from '../types/claude.js'\n\nimport { HookExitCode } from '../types/claude.js'\nimport { parseJsonInput } from '../utils/file-utils.js'\nimport { createLogger } from '../utils/logger.js'\nimport { loadSoundConfig, type ResolvedSoundConfig } from './config.js'\n\n// Cooldown tracking\nlet lastSoundTime = 0\n\n/**\n * Check if we're in quiet hours\n */\nfunction isQuietHours(config: ResolvedSoundConfig): boolean {\n  const quietConfig = config.fileConfig.filters?.quietHours\n  if (!quietConfig?.enabled) return false\n\n  const now = new Date()\n  const currentTime = now.getHours() * 100 + now.getMinutes()\n\n  const startTime = parseInt(quietConfig.start?.replace(':', '') ?? '0')\n  const endTime = parseInt(quietConfig.end?.replace(':', '') ?? '0')\n\n  if (startTime > endTime) {\n    // Crosses midnight (e.g., 22:00 to 08:00)\n    return currentTime >= startTime || currentTime <= endTime\n  } else {\n    // Same day (e.g., 13:00 to 17:00)\n    return currentTime >= startTime && currentTime <= endTime\n  }\n}\n\n/**\n * Check cooldown period\n */\nfunction checkCooldown(\n  config: ResolvedSoundConfig,\n  log: ReturnType<typeof createLogger>,\n): boolean {\n  const now = Date.now()\n  const timeSinceLastSound = now - lastSoundTime\n\n  if (timeSinceLastSound < config.cooldown) {\n    log.debug(\n      `Cooldown active: ${config.cooldown - timeSinceLastSound}ms remaining`,\n    )\n    return false\n  }\n\n  return true\n}\n\n/**\n * Play system sound\n */\nfunction playSound(\n  soundFile: string,\n  config: ResolvedSoundConfig,\n  log: ReturnType<typeof createLogger>,\n): boolean {\n  try {\n    // Check if sound file exists\n    if (!existsSync(soundFile)) {\n      log.debug(`Sound file not found: ${soundFile}`)\n      return false\n    }\n\n    // Play sound using afplay (macOS)\n    if (config.delay > 0) {\n      log.debug(`Waiting ${config.delay}ms before playing sound`)\n      setTimeout(() => {\n        execSync(`afplay \"${soundFile}\"`, { stdio: 'ignore' })\n      }, config.delay)\n    } else {\n      execSync(`afplay \"${soundFile}\"`, { stdio: 'ignore' })\n    }\n\n    lastSoundTime = Date.now()\n    log.success(`Played sound: ${path.basename(soundFile)}`)\n    return true\n  } catch (error) {\n    log.debug(\n      `Failed to play sound: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    )\n    return false\n  }\n}\n\n/**\n * Determine sound type based on tool result\n */\nfunction determineSoundType(\n  input: ClaudeToolInput,\n  config: ResolvedSoundConfig,\n  log: ReturnType<typeof createLogger>,\n): string | null {\n  const { tool_name, tool_result } = input\n\n  // Skip excluded tools\n  const excludeTools = config.fileConfig.filters?.excludeTools || []\n  if (excludeTools.includes(tool_name)) {\n    log.debug(`Tool ${tool_name} is excluded from sound notifications`)\n    return null\n  }\n\n  // Check for error indicators\n  if (tool_result) {\n    const resultStr = JSON.stringify(tool_result).toLowerCase()\n\n    if (\n      resultStr.includes('error') ||\n      resultStr.includes('failed') ||\n      resultStr.includes('\u274C')\n    ) {\n      return config.playOnError ? 'error' : null\n    }\n\n    if (resultStr.includes('warning') || resultStr.includes('\u26A0\uFE0F')) {\n      return config.playOnWarning ? 'warning' : null\n    }\n  }\n\n  // Check for success indicators\n  const successTools = config.fileConfig.triggers?.successTools || []\n  if (successTools.includes(tool_name)) {\n    return config.playOnSuccess ? 'success' : null\n  }\n\n  // Check completion patterns in tool result\n  if (tool_result) {\n    const patterns = config.fileConfig.triggers?.completionPatterns || []\n    const resultStr = JSON.stringify(tool_result).toLowerCase()\n\n    for (const pattern of patterns) {\n      if (resultStr.includes(pattern.toLowerCase())) {\n        return config.playOnSuccess ? 'success' : null\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * Main entry point\n */\nasync function main(): Promise<void> {\n  // Load configuration\n  // When built, this will be in hooks/ directory, so we need to go up to find .claude/hooks\n  const configPath = path.join(\n    process.cwd(),\n    '.claude/hooks/task-completion/hook-config.json',\n  )\n  const config = await loadSoundConfig(configPath)\n  const log = createLogger('SOUND', config.debug)\n\n  log.debug('\uD83D\uDD0A Task Completion Sound Hook - Starting...')\n\n  // Check quiet hours\n  if (isQuietHours(config)) {\n    log.debug('Quiet hours active - sounds disabled')\n    process.exit(HookExitCode.Success)\n  }\n\n  // Check cooldown\n  if (!checkCooldown(config, log)) {\n    log.debug('Cooldown active - skipping sound')\n    process.exit(HookExitCode.Success)\n  }\n\n  // Parse input\n  const input = await parseJsonInput<ClaudeToolInput>()\n  if (!input) {\n    log.debug('No valid input - exiting silently')\n    process.exit(HookExitCode.Success)\n  }\n\n  log.debug(`Processing tool: ${input.tool_name}`)\n\n  // Determine what sound to play\n  const soundType = determineSoundType(input, config, log)\n  if (!soundType) {\n    log.debug('No sound notification needed for this tool/result')\n    process.exit(HookExitCode.Success)\n  }\n\n  // Get sound configuration\n  const soundConfig =\n    config.fileConfig.sounds?.[\n      soundType as keyof typeof config.fileConfig.sounds\n    ]\n  if (!soundConfig?.enabled) {\n    log.debug(`Sound type '${soundType}' is disabled`)\n    process.exit(HookExitCode.Success)\n  }\n\n  // Try to play the sound\n  let soundPlayed = false\n\n  // Try primary sound file\n  if (soundConfig.file) {\n    soundPlayed = playSound(soundConfig.file, config, log)\n  }\n\n  // Try fallback if primary failed\n  if (!soundPlayed && soundConfig.fallback) {\n    log.debug('Trying fallback sound...')\n    soundPlayed = playSound(soundConfig.fallback, config, log)\n  }\n\n  if (!soundPlayed) {\n    log.warning(`Failed to play ${soundType} sound notification`)\n    process.exit(HookExitCode.GeneralError)\n  }\n\n  process.exit(HookExitCode.Success)\n}\n\n// Handle errors\nprocess.on('unhandledRejection', (error) => {\n  const log = createLogger('SOUND', false)\n  log.error(\n    `Unhandled error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n  )\n  process.exit(HookExitCode.GeneralError)\n})\n\n// Run main\nmain().catch((error) => {\n  const log = createLogger('SOUND', false)\n  log.error(\n    `Fatal error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n  )\n  process.exit(HookExitCode.GeneralError)\n})\n", "/**\n * Types for Claude Code hook integration\n */\n\n/**\n * Tool names that Claude Code can execute\n */\nexport type ClaudeToolName =\n  | 'Read'\n  | 'Write'\n  | 'Edit'\n  | 'MultiEdit'\n  | 'Bash'\n  | 'LS'\n  | 'Glob'\n  | 'Grep'\n  | 'NotebookEdit'\n  | 'WebFetch'\n  | 'WebSearch'\n  | 'Task'\n  | 'ExitPlanMode'\n  | 'TodoWrite'\n\n/**\n * Base structure for Claude tool input\n */\nexport interface ClaudeToolInput {\n  tool_name: ClaudeToolName\n  tool_input?: Record<string, unknown>\n  tool_result?: unknown\n}\n\n/**\n * File-related tool input\n */\nexport interface FileToolInput extends ClaudeToolInput {\n  tool_input?: {\n    file_path?: string\n    path?: string\n    notebook_path?: string\n    [key: string]: unknown\n  }\n}\n\n/**\n * Exit codes for Claude hooks\n */\nexport enum HookExitCode {\n  Success = 0,\n  GeneralError = 1,\n  QualityIssues = 2,\n}\n", "/**\n * File system utilities\n */\n\nimport { promises as fs } from 'fs'\n\nimport type { ClaudeToolInput } from '../types/claude.js'\n\n/**\n * Parse JSON input from stdin\n */\nexport async function parseJsonInput<\n  T extends ClaudeToolInput,\n>(): Promise<T | null> {\n  let inputData = ''\n\n  // Read from stdin\n  for await (const chunk of process.stdin) {\n    inputData += chunk\n  }\n\n  if (!inputData.trim()) {\n    return null\n  }\n\n  try {\n    return JSON.parse(inputData) as T\n  } catch {\n    return null\n  }\n}\n\n/**\n * Check if file exists\n */\nexport async function fileExists(filePath: string): Promise<boolean> {\n  try {\n    await fs.access(filePath)\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Check if file is a source file\n */\nexport function isSourceFile(filePath: string): boolean {\n  return /\\.(ts|tsx|js|jsx)$/.test(filePath)\n}\n\n/**\n * Read file content\n */\nexport async function readFile(filePath: string): Promise<string> {\n  return fs.readFile(filePath, 'utf8')\n}\n\n/**\n * Write file content\n */\nexport async function writeFile(\n  filePath: string,\n  content: string,\n): Promise<void> {\n  await fs.writeFile(filePath, content, 'utf8')\n}\n\n/**\n * Make file executable\n */\nexport async function makeExecutable(filePath: string): Promise<void> {\n  await fs.chmod(filePath, 0o755)\n}\n", "/**\n * Logging utilities with colored output\n */\n\n// ANSI color codes\nexport const colors = {\n  red: '\\x1b[0;31m',\n  green: '\\x1b[0;32m',\n  yellow: '\\x1b[0;33m',\n  blue: '\\x1b[0;34m',\n  cyan: '\\x1b[0;36m',\n  reset: '\\x1b[0m',\n} as const\n\nexport interface Logger {\n  info: (msg: string) => void\n  error: (msg: string) => void\n  success: (msg: string) => void\n  warning: (msg: string) => void\n  debug: (msg: string) => void\n}\n\n/**\n * Create a logger with optional debug mode\n */\nexport function createLogger(prefix: string, debug = false): Logger {\n  return {\n    info: (msg: string) =>\n      console.error(`${colors.blue}[${prefix}]${colors.reset} ${msg}`),\n    error: (msg: string) =>\n      console.error(`${colors.red}[ERROR]${colors.reset} ${msg}`),\n    success: (msg: string) =>\n      console.error(`${colors.green}[OK]${colors.reset} ${msg}`),\n    warning: (msg: string) =>\n      console.error(`${colors.yellow}[WARN]${colors.reset} ${msg}`),\n    debug: (msg: string) => {\n      if (debug) {\n        console.error(`${colors.cyan}[DEBUG]${colors.reset} ${msg}`)\n      }\n    },\n  }\n}\n", "/**\n * Configuration management for sound notification hook\n */\n\nimport { promises as fs } from 'fs'\n\nimport type { SoundNotificationConfig } from '../types/config.js'\n\nimport { parseBoolean, parseInteger } from '../utils/config-loader.js'\n\nexport interface ResolvedSoundConfig {\n  playOnSuccess: boolean\n  playOnWarning: boolean\n  playOnError: boolean\n  volume: 'low' | 'medium' | 'high'\n  delay: number\n  cooldown: number\n  minExecutionTime: number\n  debug: boolean\n  fileConfig: SoundNotificationConfig\n}\n\n/**\n * Load configuration from JSON file with environment variable overrides\n */\nexport async function loadSoundConfig(\n  configPath: string,\n): Promise<ResolvedSoundConfig> {\n  let fileConfig: SoundNotificationConfig = {}\n\n  try {\n    const content = await fs.readFile(configPath, 'utf8')\n    fileConfig = JSON.parse(content) as SoundNotificationConfig\n  } catch {\n    // Config file not found or invalid, use defaults\n  }\n\n  return {\n    // Sound settings\n    playOnSuccess:\n      process.env.CLAUDE_HOOKS_SOUND_SUCCESS !== undefined\n        ? parseBoolean(process.env.CLAUDE_HOOKS_SOUND_SUCCESS)\n        : fileConfig.settings?.playOnSuccess ?? true,\n\n    playOnWarning:\n      parseBoolean(process.env.CLAUDE_HOOKS_SOUND_WARNING, false) ||\n      (fileConfig.settings?.playOnWarning ?? false),\n\n    playOnError:\n      parseBoolean(process.env.CLAUDE_HOOKS_SOUND_ERROR, false) ||\n      (fileConfig.settings?.playOnError ?? false),\n\n    // Volume control\n    volume:\n      (process.env.CLAUDE_HOOKS_SOUND_VOLUME as 'low' | 'medium' | 'high') ||\n      (fileConfig.settings?.volume ?? 'medium'),\n\n    // Timing\n    delay:\n      parseInteger(process.env.CLAUDE_HOOKS_SOUND_DELAY) ||\n      (fileConfig.settings?.delay ?? 0),\n\n    cooldown:\n      parseInteger(process.env.CLAUDE_HOOKS_SOUND_COOLDOWN) ||\n      (fileConfig.settings?.cooldown ?? 2000),\n\n    // Filters\n    minExecutionTime:\n      parseInteger(process.env.CLAUDE_HOOKS_MIN_EXEC_TIME) ||\n      (fileConfig.filters?.minExecutionTime ?? 1000),\n\n    // Debug\n    debug: parseBoolean(process.env.CLAUDE_HOOKS_DEBUG),\n\n    // Store full config for access\n    fileConfig,\n  }\n}\n", "/**\n * Configuration loading utilities\n */\n\nimport { promises as fs, statSync } from 'fs'\nimport path from 'path'\n\n/**\n * Load JSON configuration file with environment variable overrides\n */\nexport async function loadConfig<T extends Record<string, unknown>>(\n  configPath: string,\n  envOverrides: Record<string, (value: string | undefined) => unknown> = {},\n): Promise<T | null> {\n  let fileConfig: T | null = null\n\n  // Try to load file config\n  try {\n    const content = await fs.readFile(configPath, 'utf8')\n    fileConfig = JSON.parse(content) as T\n  } catch {\n    // Config file not found or invalid\n    return null\n  }\n\n  // Apply environment variable overrides\n  const config = { ...fileConfig }\n\n  for (const [envKey, transformer] of Object.entries(envOverrides)) {\n    const envValue = process.env[envKey]\n    if (envValue !== undefined) {\n      const transformed = transformer(envValue)\n      if (transformed !== undefined) {\n        // Apply the transformed value to the config\n        // This is a simplified version - in real implementation\n        // we'd need to handle nested paths\n        Object.assign(config, transformed)\n      }\n    }\n  }\n\n  return config\n}\n\n/**\n * Find project root by looking for package.json\n */\nexport function findProjectRoot(startPath: string): string {\n  let currentPath = startPath\n  while (currentPath !== '/') {\n    try {\n      const stat = statSync(path.join(currentPath, 'package.json'))\n      if (stat.isFile()) {\n        return currentPath\n      }\n    } catch {\n      // Continue searching\n    }\n    currentPath = path.dirname(currentPath)\n  }\n  return process.cwd()\n}\n\n/**\n * Parse boolean environment variable\n */\nexport function parseBoolean(\n  value: string | undefined,\n  defaultValue = false,\n): boolean {\n  if (value === undefined) return defaultValue\n  return value !== 'false'\n}\n\n/**\n * Parse integer environment variable\n */\nexport function parseInteger(\n  value: string | undefined,\n  defaultValue = 0,\n): number {\n  if (value === undefined) return defaultValue\n  const parsed = parseInt(value, 10)\n  return isNaN(parsed) ? defaultValue : parsed\n}\n"],
  "mappings": "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",
  "names": ["import_fs", "HookExitCode", "fs", "path"]
}
